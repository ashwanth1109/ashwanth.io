---
title: "Building React MicroFrontends with Webpack Module Federation"
date: 2021-02-03
slug: "/react-microfrontends-webpack-module-federation"
tags:
- React
- Frontend
- Webpack
- Talk
---

Earlier this week, I spoke at the online react meetup organized by the react community in Bangalore.
I spoke about "Building React MicroFrontends (MFEs) with Webpack Module Federation".

You can watch the talk [here](https://www.youtube.com/watch?v=-U5Jx17TrG8&t=270s)
The talk contains live code demonstrations which are not covered by the excerpt below.

# What are MFEs?

In recent years, there's been this wide popularization of building services as microservices on the backend.
And MFEs are essentially an extension of this idea to the frontend.
Typically, most of our SPAs are monoliths where your entire frontend is one entity, hosted on one repository.
And you deploy it as a single unit using a CICD pipeline.

With an MFE architecture, you split the monolith frontend into parts. For example, one part could be a product detail page and another part could be a shopping cart page.
Each of these parts would be an MFE and would have its own CICD pipeline and development lifecycle.
This way, one team would develop the product detail page on some port (e.g 8001).
The second team would build the shopping cart page on another port 8002.
You can then integrate these MFEs into a container shell, that's hosted on port 8000 into one integrated application.

# Why do we need MFEs in the first place?

## 1. Multiple engineering teams can work (in isolation) on the same SPA
SPAs today tend to be really bloated with sophisticated features.
With MFEs, you're enabling different engineering teams to work in isolation on the same application.
So, you would have a shopping cart team that is only working on the shopping cart feature from end-to-end.
That is, the frontend is built as an MFE, and the backend is built as a microservice.

## 2. Enforces decoupled modules, independent deployability
A good MFE architecture enforces decoupled modules.
This way, you can prevent inappropriate or unintentional coupling across these modules.
Each MFE would be deployed independently, and you tend to have faster, smaller deployments.
Any pipeline that builds, tests, analyzes, and deploys your code will take much less time because changes in one MFE only trigger the pipeline for that MFE.
This means PRs can also get merged faster.

## 3. Can use other frameworks simultaneously and migrate in parts
The frontend ecosystem today moves at an insane speed.
We have several frontend frameworks coming out over the years, and with MFEs you can build one portion in React, and one in Vue and they can coexist at the same time on your application.
Similarly, lets say you want to migrate your MFE from React to Svelte, you can do this just for one MFE, and your application as a whole will still continue to work.

# Types of Integration

## Build-time integration

In this approach, you would build your component, say header as a separate npm package and publish it to the npm repository.
You can then npm install this package in your container shell and then use this package.

## Server-side integration

One way to implement server side integration - is to serve different MFEs on different routes.
So, lets say you have a client that requests a page on route "/product/1".
Your server would handle this request and serve the product details page.
If the client requests the route "/shopping-cart", then the server would serve the shopping cart page.

## iFrame integration

If you have two MFEs hosted on different URLs or ports, you can integrate these MFEs into your container application as iframes.

## Run-time integration

This integration is the focus of the talk. Webpack module federation is one way to accomplish run-time integration.
The gist of this approach is to have MFEs dynamically integrated at run-time.
You can see my code example of run-time integration without Module Federation [here](https://youtu.be/-U5Jx17TrG8?t=550)

# Module Federation

Module Federation is an architectural pattern that is provided as an extension to webpack functionality using a plugin.
The idea behind module federation is to develop multiple modules separately with no dependencies or coupling between them so that they can be built and deployed individually.
You can then group these modules together to form a single cohesive application.

Module federation is not only built for MFEs.
You can use the same pattern in a nodejs environment as well, although MFEs are the prevalent use case for this.

You can see my code example of run-time integration using Module Federation [here](https://youtu.be/-U5Jx17TrG8?t=1041)
